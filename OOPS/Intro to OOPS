"""
Focuses on creating "objects" that combine data and the functions that operate on that data.
For e.g. - a Rectangle object that contains its length and width and has an area() method.
Procedural coding → code repetition problem
Functions → reduced repetition but lacked data security and structure
OOP → better organization, security, reusability, and scalability
"""

# OOPS is based on 'Class' and 'Object' relationships.
# Class
"""
A class is a blueprint, a template, or a prototype for creating objects.
It defines the common attributes (data/properties) and methods (functions/behaviors) that all objects of that type will have.
Classes don't store data themselves; they define the structure for data.
"""
# Object
"""
An object (also called an instance) is a concrete realization of a class.
It's a specific entity created based on the class's blueprint.
Each object has its own unique set of attribute values.
"""
# Attributes
"""
The attributes are the data associated with an object and its properties.
"""

#####################################################################################################################################################

class Student:                        # Class
    pass

student1 = Student()                  # Object
student1.name = "John"                # Attribute of student1 (external) - name
student1.age = 18                     # Attribute of student1 (external) - age

print(student1.name)
print(student1.age)

""" 
This way, you will have to give each object their attributes individually in full follow up form.
This is time taking so it is considered a wrong way.
The one below is better way.
"""
#####################################################################################################################################################

class Person:                         # Class named "Person"
    def __init__(self, name, age):    # Constructor : __init__. Also a Initializer.
# "__init__" is a Dundar. It means 'Double Dash'. Anything with '__' around it is called a Dundar. Eg : '__main__'.
        self.name = name              # self is a keyword that means that it's calling for itself.
        self.age = age                # Name and Age are Instance Attributes
    pass                              # If no functionality is given, we simply use pass

P1 = Person("Bob", 22)                # Object (instances of the class) named "P1"
                                      # "Bob" and 22 are the value of the attributes

print(P1)                             # Output : <__main__.Person object at 0x00000190C6FC70E0>
"""
When you write print(P1) :-
Python internally does the following:
- print(P1.__str__())
or, if __str__() is not defined:
- print(P1.__repr__())

In this Case, none of the two is defined.
So Python falls back to the default implementation provided by the base object class.
| Part                 | Meaning                                              |
| -------------------- | ---------------------------------------------------- |
| `__main__`           | The module where the class is defined (current file) |
| `Person`             | Class name                                           |
| `object`             | Indicates it is an object instance                   |
| `0x00000190C6FC70E0` | Memory address of the object (in hexadecimal)        |
"""

#####################################################################################################################################################

class Persons:                        # Class named "Persons".
    def __init__(self, name, age):    # No need to give argument in () whose value is fixed already.
        self.name = name
        self.age = age
        self.species = "Human"

    def getName(self):                # Instance Method 1 (Functionality) named 'getName'
        return self.name
    
    def getAge(self):                 # Instance Method 2
        return self.age
    
    def getSelf(self):
        return self                   # Will give same value as its current object

P1 = Persons("Bob", 22)                # Object named "P1"
                                       # "Bob" and 22 are values of attributes
P2 = Persons("Ross",26)

print(P1)
print(P1.getName())
print(P1.getAge())
print(P1.__dict__)
P1.hobby = "Cricket"
print(P1.__dict__)

print(P2.__dict__)


"""
When we call an instance method using the object/instance of the class, Python passes the object itself as the first argument to that ethod
That first argument is self (by standard).
P1.getName() is internally treated as Persons.getName(P1)
"""

###############################
# Class Variables and Methods #
###############################

class Student:                                           # Class named "Student".
                       
    college = "ABC College"                              # Class Variable
    section = ["CSE", "Electrical", "Mechanical"]        # Class Variable
                       
    def __init__(self, name, role):                      # No need to give argument in () whose value is fixed already.
        self.name = name                   
        self.roll = role
        self.student = "Yes"
                   
    def getName(self):                                   # Instance Method 1 (Functionality) named 'getName'
        return self.name                   
                       
    def getAge(self):                                    # Instance Method 2
        return self.age
    
    def showCollege(self):
        return self.college

s1 = Student("RJ","Student")
print(s1.college)
print(s1.section)

print(Student.college)
print(Student.section)


"""_______________________________________________________________________________________________________________________________________________"""

class Office:
    
    office = "ABC Work"
    department = ["Sales", "HR", "Developer"]
    
    def __init__(self, name, role):
        self.name = name
        self.role = role
        self.employee = "Yes"
    
    # ---------- Instance Methods ----------
    def getName(self):
        return self.name
    
    def getRole(self):
        return self.role
    
    def showOffice(self):
        return self.office
    
    # ---------- Class Methods (Decorators) ----------
    @classmethod
    def greet(cls):
        print(f"Welcome to {cls.office}")
    
    @classmethod
    def showDepartments(cls):
        print("Departments available:")
        for dept in cls.department:
            print("-", dept)
    
    @classmethod
    def changeOfficeName(cls, new_name):
        cls.office = new_name
    
    @classmethod
    def totalDepartments(cls):
        return len(cls.department)

w1 = Office("RJ", "Head")

w1.greet()
w1.showDepartments()

Office.changeOfficeName("XYZ Corporation")
w1.greet()

print("Total departments:", Office.totalDepartments())


#################
# Static Method #
#################

class Office:
    
    office = "ABC Work"
    department = ["Sales", "HR", "Developer"]
    
    def __init__(self, name, role):
        self.name = name
        self.role = role

    def work(self, n):
        return f"{self.name} works for {n} hours a day."
    
    # ---------- Static Method ----------
    @staticmethod
    def isValidRole(role):
        return role in ["Head", "Manager", "Employee"]
    
    @staticmethod
    def greetEmployee(name, office_name):
        print(f"Welcome {name} to {office_name}")


"""
Static methods are utility functions placed inside a class that do not operate on instance or class data.
No "self" or "cls" in it. 
Data is entered directly when called.
No dependency on class or instance.
"""

w1 = Office("RJ", "Head")
print(Office.isValidRole("Head"))
print(w1.isValidRole("Intern"))

print(w1.work(6))

Office.greetEmployee("RJ", "ABC Work")          # No Class dependency
